
# Working with Data Frames

Now that we know how to obtain a `DataFrame`, let's start working with one.

For example, this dataset of grocery products:

```{python}
from pandas import read_csv

request_url = (
    "https://raw.githubusercontent.com/prof-rossetti/intro-to-python" +
    "/main/data/products.csv"
)
df = read_csv(request_url)
print(type(df))
```



## Previewing the Data

We can preview the first few rows or last few rows using the `head` or `tail` methods, respectively.

Previewing the first few rows:

```{python}
df.head()
```

Previewing the last few rows:

```{python}
df.tail()
```

By default, we see five rows, but we can customize the number of rows by passing an integer parameter to these methods, like `head(3)` or `tail(3)`.

## Dataset Properties

### Size and Shape

Counting number of rows, by passing the `DataFrame` to the familiar `len` function:

```{python}
len(df)
```


Alternatively we can access the `shape` property, which tells us the dataset size in terms of number of rows and columns:

```{python}
df.shape
```

:::{.callout-note}
The `shape` is a tuple formatted as `(n_rows, n_cols)`, where the first value represents the number of rows, and the second represents the number of columns.
:::

Accessing the `shape` is especially helpful when working with multidimensional data (i.e. data in three or more dimensions).


### Column Names

Identifying column names, using the `columns` property:

```{python}
df.columns
```

We get back a list-like object, which we can convert to a simple list using the `tolist` method:

```{python}
df.columns.tolist()
```

:::{.callout-note title="FYI"}
The `tolist` method is used across the `numpy` and `pandas` packages to convert specialized data structures to simple Python lists.
:::

## Accessing the Index

Every `DataFrame` object has an index, which is a set of unique row identifiers.

The default index is a set of auto-incrementing numbers starting at 0.

```{python}
df.index
```

We get back a list-like object, which we can convert to a simple list using the `tolist` method:

```{python}
df.index.tolist()
```


### Accessing Rows

To reference a given row, we use a list-like accessor in conjunction with the `iloc` method.

In this example, we are accessing the first row, using an index value of `0`. When we access a single row, we get a `Series` object back:

```{python}
first_row = df.iloc[0]
print(type(first_row))
first_row
```

In this example, we are accessing the first three rows, using a list slicing approach. When we access multiple rows, we get a `DataFrame` object back:

```{python}
first_three = df.iloc[0:3]
print(type(first_three))
first_three
```

:::{.callout-warning  title="FYI"}
When we use index references like this with the `iloc` method, we are actually referencing the index value itself (which by default is an auto-incrementing integer starting at zero, but may change), not the position of the row in the dataset.
:::



## Accessing Columns

We can access one or more columns worth of values, using a dictionary-like accessor.

To access a single column, we pass the string column name, and we get a pandas `Series` object back:

```{python}
product_names = df["name"]
print(type(product_names))
product_names
```

To access multiple columns, we pass a list of string column names, and we get a `DataFrame` object back:

```{python}
products_slim = df[["id", "name", "price"]]

print(type(products_slim))

products_slim.head()
```

## Exporting Data

### To List of Dictionaries ("Records" Format)

Converting a `DataFrame` to a list of dictionaries, using the `to_dict` method:
```{python}
products = df.to_dict("records")

print(type(products))
print(len(products))
print(type(products[0]))
products[0]
```

:::{.callout-note title="FYI"}
Here, the "records" parameter value has nothing to do with any of the columns in the dataset, but rather the format in which to export the data. The "records" format refers to a list of dictionaries.
:::


### To CSV File

We can use the [`to_csv` method](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.to_csv.html) to export a `DataFrame` to a CSV file.

As a parameter, we specify the name of the CSV file that should be created (in this case, "products_copy.csv"), as well as whether or not to include the index column:

```{python}
df.to_csv("products_copy.csv", index=False)
```

In Colab, the file will be saved to the Colab Filesystem, where we have the ability to download the file to our local machine.

```{python}
import os

os.path.isfile("products_copy.csv")
```



```{python}
#| echo: false

import os
# CLEAN UP:
os.remove("products_copy.csv")
```
