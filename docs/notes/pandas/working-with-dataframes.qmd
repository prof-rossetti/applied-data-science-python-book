
# Working with Data Frames

Now that we know how to obtain a `DataFrame`, let's start working with one.

For example, this dataset of grocery products:

```{python}
from pandas import read_csv

request_url = "https://raw.githubusercontent.com/prof-rossetti/intro-to-python/main/data/products.csv"
df = read_csv(request_url)
print(type(df))
```



## Previewing the Data

We can preview the first few rows or last few rows using the `head` or `tail` methods, respectively.

Previewing the first few rows:

```{python}
df.head()
```

Previewing the last few rows:

```{python}
df.tail()
```

By default, we see five rows, but we can customize the number of rows by passing an integer parameter to these methods, like `head(3)` or `tail(3)`.

## Dataset Properties

### Size and Shape

Counting number of rows, by passing the `DataFrame` to the familiar `len` function:

```{python}
len(df)
```


Alternatively we can access the `shape` property, which tells us the dataset size in terms of number of rows and columns:

```{python}
df.shape
```

:::{.callout-note}
The `shape` is a tuple formatted as `(n_rows, n_cols)`, where the first value represents the number of rows, and the second represents the number of columns.
:::

Accessing the `shape` is especially helpful when working with multidimensional data (i.e. data in three or more dimensions).


### Column Names

Identifying column names, using the `columns` property:

```{python}
df.columns
```

We get back a list-like object, which we can convert to a simple list using the `tolist` method:

```{python}
df.columns.tolist()
```

:::{.callout-note title="FYI"}
The `tolist` method is used across the `numpy` and `pandas` packages to convert specialized data structures to simple Python lists.
:::

### Row Index Values

Every `DataFrame` object has an index, which is a set of unique row identifiers.

The default index is a set of auto-incrementing numbers starting at 0.

```{python}
df.index
```

When we reference the index, we get back a list-like object, which we can convert to a simple list using the `tolist` method:

```{python}
df.index.tolist()
```


## Accessing Columns

We can access one or more columns worth of values, using a dictionary-like accessor.

To access a single column, we pass the string column name, and we get a pandas `Series` object back:

```{python}
names = df["name"]
print(type(names))
names.head()
```

To access multiple columns, we pass a list of string column names, and we get a `DataFrame` object back:

```{python}
names_and_prices = df[["name", "price"]]
print(type(names_and_prices))
names_and_prices.head()
```
## Accessing Rows

To reference a given row, we use a list-like accessor in conjunction with the `iloc` method.

In this example, we are accessing the first row, using an index value of `0`. When we access a single row, we get a `Series` object back:

```{python}
first_row = df.iloc[0]
print(type(first_row))
first_row
```

In this example, we are accessing the first three rows, using a list slicing approach. When we access multiple rows, we get a `DataFrame` object back:

```{python}
first_three = df.iloc[0:3]
print(type(first_three))
first_three
```

:::{.callout-note}
When we use index references like this with the `iloc` method, we are actually referencing the index value itself, not the position of the row in the dataset. In the event the index values change, you would need to use the new values instead of the default integer values.
:::




## Accessing Cell Values

It is possible to access individual values using the `loc` method, or a row-based approach, or a column-based approach.


The `loc` method, specifying the given row index value, and the column name:

```{python}
df.loc[0, "name"]
```

Row-based approach, using the aforementioned `iloc` method gets us the first row, then we access one of its values using a dictionary-like accessor:

```{python}
df.iloc[0]["name"]
```

Column-based approach, referencing the column name to get us the column, then we access one of its values using a list-like accessor:

```{python}
df["name"][0]
```
