---
format:
  html:
    code-fold: false #show
jupyter: python3
execute:
  cache: true # re-render only when source changes
---

# Column Operations


In this chapter we will focus on column operations, including dropping, renaming, and mapping columns.

For these examples, we will use our familiar dataset of products:

```{python}
from pandas import read_csv

request_url = "https://raw.githubusercontent.com/prof-rossetti/intro-to-python/main/data/products.csv"
df = read_csv(request_url)
df.head()
```


## Column as a `Series`

Remember, when we access a given column of values, we are working with a `Series` object:

```{python}
names = df["name"]
print(type(names))
names.head()
```

With a `Series` object as a column, we can use list-like accessors to access one of the values based on its index value:

```{python}
names[0]
```

And we can convert the `Series` object to a normal list as desired:

```{python}
names.tolist()
```

### Series Aggregations

One of the cool things about `Series` objects is they know how to calculate their own aggregations.

For example, minimum and maximum values:

```{python}
print("MIN PRICE:", df["price"].min())
print("MAX PRICE:", df["price"].max())
```

Mean and median values:

```{python}
print("MEAN PRICE:", df["price"].mean().round(2))
print("MEDIAN PRICE:", df["price"].median())
```

Percentiles, etc:

```{python}
print("25th PCT PRICE:", df["price"].quantile(.25).round(2))
print("75th PCT PRICE:", df["price"].quantile(.75).round(2))
```


### Value Counts

The `value_counts` method shows us a count of the number of rows for each value in a given column:

```{python}
df["department"].value_counts()
```

We can use the `normalize` parameter to display our counts as percentage of the total number of rows:

```{python}
df["department"].value_counts(normalize=True)
```



## Renaming Columns

We can use the [`rename` method](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.rename.html) to rename columns. This is not mutating unless we use the `inplace` parameter.


```{python}
df.rename(columns={"department": "dept"}, inplace=True)
df.head()
```

## Dropping Columns

We can use the [`drop` method](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.drop.html) to remove columns from the dataset. This is not mutating unless we use the `inplace` parameter.


```{python}
df.drop(columns=["aisle"], inplace=True)
df.head()
```

## Creating New Columns

We can create a new column by specifying the name of that column and assigning a new value. For example, a column of constants:

```{python}
df["inflation_factor"] = 1.5
df.head()
```

In practice, instead of creating a new column of constants or placeholder values, we will generally create a new column of transformed values (see "Mapping Columns" section below).


## Mapping Columns

We can transform the values in a given column, performing the transformation using either a constant scalar value, or another column of values.

When mapping using a single scalar value, for example multiplying by 1.5, each value in the original column gets multiplied by that same value:

```{python}
df["inflated_price"] = (df["price"] * 1.5).round(2)
df[["id", "name", "price", "inflated_price"]].head()
```

When mapping using two `Series` objects, this performs an element-wise operation where the first values in each series are compared, then the second values, etc.


```{python}
df["inflated_price"] = (df["price"] * df["inflation_factor"]).round(2)
df[["id", "name", "price", "inflation_factor", "inflated_price"]].head()
```


This essentially allows us to access and compare multiple values from the same row.




### Applying a Mapping Dictionary

If we want to change certain values, we can use the `map` method in conjunction with a dictionary mapping of new values:

```{python}
departments_map = {
  "beverages": "BV",
  "frozen": "FR",
  "pantry": "PN",
  "snacks": "SN",
  "personal care": "PC",
  "dairy eggs": "DE",
  "household": "HH",
  "babies": "BB",
  "meat seafood": "MS",
  "dry goods pasta": "DG",
}
df["dept_abbrev"] = df["dept"].map(departments_map)
df[["id", "name", "dept", "dept_abbrev"]].head()
```

### Applying a Transformation Function

For more complex logic, we can use the [`apply` method](https://pandas.pydata.org/docs/reference/api/pandas.Series.apply.html) to apply a transformation function.

We define our own transformation function which accepts a single parameter representing one of the values in the original series we are applying the transformation over, and return the transformed value.

Then we pass that transformation function as a parameter to the `apply` method:

```{python}
# transformation function:

def inflated_price(original_price):
    # only inflate if the price is greater than $5
    if original_price < 5.00:
        return original_price
    else:
        return original_price * 1.5

assert inflated_price(3.00) == 3.00
assert inflated_price(10.00) == 15.00
```

```{python}
df["inflated_price"] = df["price"].apply(inflated_price).round(2)
df[["id", "name", "price", "inflated_price"]].head()
```
